\section{Handling Non-Determinism}
\label{sec:nondet}
The typing judgements proposed in Section \ref{subsec:judgements} lead to ambiguity.
In this section we propose ways to get our derivations to a certain normal form, by deriving an equivalence relation on our derivation and parsing trees, based on string diagrams.

\subsection{String Diagram Modelisation of Sentences}
\label{subsec:sd}
String diagrams are the Poincar√© duals of the usual categorical diagrams when
considered in the $2$-category of categories and functors.
This means that we represent categories as regions of the plane, functors as
lines separating regions and natural transformations as the intersection points
between two lines.
We will always consider application as applying to the right of the line so
that composition is written in the same way as in equations.
This gives us a new graphical formalism to represent our effects using a few
equality rules between diagrams.
The commutative aspect of functional diagrams is now replaced by an equality of
string diagrams, which will be detailed in the following section.

The important aspect of string diagrams that we will use is that two diagrams that are planarily homotopic are equal \cite{joyalGeometryTensorCalculus1991} and that we can map a string diagram to a sequence of computations on computation: the vertical composition of natural transformations (bottom-up) represents the reductions that we can do on our set of effects.
This means that even when adding handlers, we get a way to visually see the meaning get reduced from effectful composition to propositional values, without the need to specify what the handler does.
Indeed we only look at \emph{when} we apply handlers and natural transformations reducing the number of effects.
This delimits our usage of string diagrams as ways to look at computations and a tool to provide equality rules to reduce non-determinism by constructing an equivalence relationship (which we denote by $\eqcirc$) and yielding a quotient set of \emph{normal forms} for our computations.

Let us define the category $\mathds{1}$ with exactly one object and one arrow: the identity on that object. It will be shown in grey in the string diagrams below.
A functor of type $\mathds{1} \to \mC$ is equivalent to choosing an object in $\mC$, and a natural between two such functors $\tau_{1}, \tau_{2}$ is exactly an arrow in $\mC$ of type $\tau_{1} \to \tau_{2}$.
Knowing that allows us to represent the type resulting from a sequence of computations as a sequence of strings whose farthest right represents an object in $\mC$, that is, a base type.
\begin{wrapfigure}{l}{.45\textwidth}
	\begin{center}
		\input{aux/figures/sd-thecatsleeps}
	\end{center}
\end{wrapfigure}

For simplicity reasons, and because the effects that are buried in our typing system not only give rise to functors but also have types that are not purely currifiable, we will write our string diagrams on the fully parsed sentence, with its most simplified/composed expression.
Indeed, the question of providing rules to compose the string diagram for \textbf{the} and the one for \textbf{cat} to give the one for \textbf{the cat} is a difficult question, that natural solutions to are not obvious, and will be discussed in the next section.

\medskip

To justify our proposition to only consider fully reduced expressions note that
in this formalism we don't consider the expressions for our functors and
natural transformations but simply the sequence in which they are applied.
This works since the following diagrams commute for any $F, G$ functors and
$\theta$ natural transformation:
\begin{center}
	\begin{tikzcd}
		G\ar[r, "F"]\ar[d, "\theta"'] & F\circ G\ar[d, "F\circ \theta"] &[.5cm] G\ar[r, "F"]\ar[d, "\theta"'] & G\circ F \ar[d, "\theta\circ F"] \\
		\theta G\ar[r, "F"'] & F\circ \theta G & \theta G\ar[r, "F"'] & \theta G \circ F
	\end{tikzcd}
\end{center}
The property of natural transformations to be applied before or after any arrow in the category justifies that even when composing before the handling we get the same result.
These properties justifies the fact that we only need to prove the equality of
two reductions at the farthest step of the reductions, even though in practice
the handling might be done at earlier points in the parsing.

In the end, we will have the need to go from a certain set of strings (the effects that applied) to a single one, through a sequence of handlers, monadic and comonadic rules and so on.
Notice that we never reference the zero-cells and that in particular their colors are purely an artistical touch.

\medskip

There is however one thing that may seem to be an issue: existential quantifiers inside \textbf{if then} sentences and other functions looking like $\f{M}\ty{a} \to \ty{b}$.
Indeed, \cite{bumfordEffectdrivenInterpretationFunctors2025} suggests that those could be of type $\f{S}\t \to \t$ and that we might want to apply that function to something of type $\f{S}\t$ by first using the unit of the monad $\f{S}$ then invoking \texttt{fmap}.
There is no issue with that in our typing system, as this combination mode is
the composition of two typing judgements (in a sense).
To graphically reconciliate this and our string diagrams, especially since
units and handlers cancel each other, we suggest to see the effects as being
dragged along the parsing trees (or parsing string diagrams) until they're
never needed again.

\subsection{Achieving Normal Forms}
\label{subsec:normalforms}
We will now provide a set of rewriting rules on string diagrams (written as
equations) which define the set of different possible reductions.

First, Theorem \ref{thm:isotopy} reminds the main result by \cite{joyalGeometryTensorCalculus1991} about string diagrams which shows that our artistic representation of diagrams is correct and does not modify the equation or the rule we are presenting.
\begin{theorem}[Theorem 1.2 \cite{joyalGeometryTensorCalculus1991}]
	\label{thm:isotopy}
	A well-formed equation between morphism terms in the language of monoidal categories follows from the axioms of monoidal categories if and only if it holds, up to planar isotopy, in the graphical language.
\end{theorem}

Secondly, let us now look at a few of the equations that arise from the
commutation of certain class of diagrams:
\begin{description}
	\item[The \emph{Elevator} Equations] are a consequence of Theorem
	      \ref{thm:isotopy} but also highlight one of the most important properties
	      of string diagrams in their modelisation of multi-threaded computations:
	      what happens on one string does not influence what happens on another in
	      the same time.
	\item[The \emph{Snake} Equations] are a rewriting of the categorical diagrams
	      which are the defining properties of an adjunction.
	\item[The \emph{(co-)Monadic} Equations] are the string diagrammatic
	      translation of the properties of unitality and associativity of the
	      monad.
	      Similarly, there are co-monadic equations which are the categorical dual
	      of the previous equations.
\end{description}
This set of equations, when added to our reduction rules from the Section
\ref{sec:parsing} explain all the different reductions that can be made to
limit non-determinism in our parsing strategies.
Indeed, considering the equivalence relation $\mathcal{R}$ freely generated
from the equations defined above and the equivalence relationship
$\mathcal{R}'$ of planar isotopy from Theorem \ref{thm:isotopy}, we get a set
of normal forms $\mathcal{N}$ from the set of all well-formed parsing diagrams
$\mD$ defined by:
$\mathcal{N} = \left( \mD / \mathcal{R} \right) / \mathcal{R}'$


\subsection{Computing Normal Forms}
Now that we have a set of rules telling us what we can and cannot do in our model while preserving the equality of the diagrams, we provide a combinatorial description of our diagrams to help compute the possible equalities between multiple reductions of a sentence meaning.

\cite{delpeuchNormalizationPlanarString2022} proposed a combinatorial description to check
in linear time for equality under Theorem \ref{thm:isotopy}.
However, this model does not suffice to account for all of our equations, especially as
labelling will influence the equations for monads, comonads and adjunctions.
To provide with more flexibility (in exchange for a bit of time complexity) we use the
description provided and change the description of inputs and outputs of each $2$-cell by
adding types and enforcing types.
In this section we formally describe the data structure we propose, as well as algorithms for
validity of diagrams and a system of rewriting that allows us to compute the normal forms
for our system of effects.

\subsubsection{Representing String Diagrams}
We follow \cite{delpeuchNormalizationPlanarString2022} in their combinatorial description
of string diagrams. We describe a diagram by an ordered set of its $2$-cells (the natural
transformations) along with the number of input strings, for each $2$-cell the following
information:
\begin{itemize}
	\item Its horizontal position: the number of strings that are right of it (we adopt this
	      convention to match our graphical representation of effects: the number of strings
	      is the distance to the base type).
	\item Its type: an array of effects (read from left to right) that are the inputs to the
	      natural transformation and an array of effects that are the outputs to the natural
	      transformation. The empty array represents the identity functor.
	      Of course, we will not actually copy arrays and arrays inside our datastructure but
	      simply copy labels which are keys to a dictionary containing such arrays to limit
	      the size of our structure, allowing for $\O(1)$ access to the associated properties.
\end{itemize}
We will then write a diagram $D$ as a tuple of $3$ elements\footnote{We could write it
	as a tuple of $5$ elements by replacing $\dl{D}$ by three functions that lower level}:
$\left( D.N, D.S, D.L \right)$ where $D.N$ is a positive integers representing the
height (or number of nodes) of $D$, $D.S$ is an array for the input strings of $D$ and
where $D.L$ is a function which takes a natural number smaller than $D.N - 1$ and
returns its type as a tuple of arrays
$nat = \left( \dnlg{nat}, \dnin{nat}, \dnout{nat} \right)$.
From this, we can derive a naive algorithm to check if a string diagram is
valid or not.

\medskip

Since our representation contains strictly more information (without slowing
access by a non-constant factor) than the one it is based on, our
datastructure supports the linear and polynomial time algorithms proposed with
the structure by \cite{delpeuchNormalizationPlanarString2022}.
This in particular means that our structure can be normalized in polynomial
time to check for equality under Theorem \ref{thm:isotopy}.
More precisely, the complexity of our algorithm is in $\O\left( n \times
	\sup_{i} \abs{\dnin{\dlb{D}{i}}} + \abs{\dnout{\dlb{D}{i}}} \right)$, which
depends on our lexicon but most of the times will be linear time.

\subsubsection{Equational Reductions}
We are faced a problem when computing reductions using the equations for our diagrams
which is that by definition, an equation is symmetric.
To solve this issue, we only use equations from left to right to reduce as much as
possible our result instead.
This also means that trivially our reduction system computes normal forms: it suffices
to re-apply the algorithm for recumbent equivalence after the rest of equational
reduction is done.
Moreover, note that all our reductions are either incompatible or commutative, which
leads to a confluent reduction system, and the well definition of our normal forms:
\begin{theorem}[Confluence]\label{thm:confluence}
	Our reduction system is confluent and therefore defines normal forms:
	\begin{enumerate}
		\item Right reductions are confluent and therefore define \emph{right} normal forms for
		      diagrams under the equivalence relation induced by exchange.
		\item Equational reductions are confluent and therefore define \emph{equational}
		      normal forms for diagrams under the equivalence relation induced by exchange.
	\end{enumerate}
\end{theorem}

Before proving the theorem, let us first provide the reductions for the different
equations for our description of string diagrams.
\begin{description}
	\item[The Snake Equations]
	      First, let's see when we can apply the equation for $\id_{L}$ to a
	      diagram $D$ which is in \emph{right} normal form, meaning it's been
	      right reduced as much as possible.
	      Suppose we have an adjunction $L \dashv R$.
	      Then we can reduce $D$ along the equation at $i$ if, and only if:
	      \begin{itemize}
		      \item $\dnlg{\dlb{D}{i}} = \dnlg{\dlb{D}{i + 1}} - 1$
		      \item $\dlb{D}{i} = \eta_{L, R}$
		      \item $\dlb{D}{i + 1} = \epsilon_{L, R}$
	      \end{itemize}
	      This comes from the fact that we can't send either $\epsilon$
	      above $\eta$ (or the other way around) using right reductions and
	      that there cannot be any natural transformations between the two.
	      Obviously the equation for $\id_{R}$ works the same.
	      Then, the reduction is easy: we simply delete both strings,
	      removing $i$ and $i + 1$ from $D$ and reindexing the other nodes.
	\item[The Monadic Equations] For the monadic equations, we only use
	      the unitality equation as a way to reduce the number of natural
	      transformations, since the goal here is to attain normal forms
	      and not find all possible reductions.
	      We ask that associativity is always used in the direct
	      sense $\mu\left( \mu\left( TT \right),T \right) \to \mu\left(
		      T\mu\left( TT \right) \right)$ so that the algorithm terminates.
	      We use the same convention for the comonadic equations.
	      The validity conditions are as easy to define for the monadic
	      equations as for the \emph{snake} equations when considering
	      diagrams in \emph{right} normal forms.
	      Then, for unitality we simply delete the nodes
	      and for associativity we switch the horizontal
	      positions for $i$ and $i + 1$.
\end{description}

\begin{proof}[Proof of the Confluence Theorem]
	The first point of this theorem is exactly Theorem 4.2
	in \cite{delpeuchNormalizationPlanarString2022}.
	To prove the second part, note that the reduction process terminates as
	we strictly decrease the number of $2$-cells with each reduction.
	Moreover, our claim that the reduction process is confluent is obvious
	from the associativity equation and the fact the other
	equations delete nodes.
	Since right reductions do not modify the equational reductions, and thus
	right reducing an equational normal form yields an equational normal form,
	combining the two systems is done without issue, completing our proof of
	Theorem \ref{thm:confluence}.
\end{proof}


\begin{theorem}[Normalization Complexity]
	\label{thm:normalize}
	Reducing a diagram to its normal form is done in polynomial time in
	the number of natural transformations in it.
\end{theorem}
\begin{proof}
	Let's now give an upper bound on the number of reductions.
	Since each reductions either reduces the number of $2$-cells or applies the
	associativity of a monad, we know the number of reductions is linear in the
	number of natural transformations.
	Moreover, since checking if a reduction is possible at height $i$ is done in
	constant time, checking if a reduction is possible at a step is done in
	linear time, rendering the reduction algorithm quadratic in the number of
	natural transformations.
	Since we need to \emph{right} normalize before and after this method, and
	that this is done in linear time, our theorem is proved.
\end{proof}

