\section{Categorical Semantics of Effects: A Typing System}
\label{sec:typingsystem}
In this section, we will designate by $\mL$ our language, as a set of words
(with their semantics) and syntactic rules to combine them semantically.
We denote by $\O\left( \mL \right)$ the set of words in the language whose
semantic representation is a low-order function and $\mF\left( \mL \right)$ the
set of words whose semantic representation is a functor or high-order function.
Our goals here are to describe more formally, using a categorical vocabulary,
the environment in which the typing system for our language will exist, and how
we connect words and other linguistic objects to the categorical formulation.

\subsection{Typing Category}\label{subsec:typingcategory}
\subsubsection{Types}\label{subsubsec:types}
Let $\mC$ be a closed cartesian category, which will be used to represent the
domain of types for our domain of denotations.
This represents our main typing system, consisting of words $\O(\mL)$ that can
be expressed without effects (see Figure \ref{fig:lexicon} for an example).
Remember that $\mC$ contains a terminal object $\bot$ representing the empty
type or the lack thereof.
We consider $\bar{\mC}$ the category closure of
$\mF\left( \mL \right)\left(\mC\right)$, that is consisting of
all the different type constructors (ergo, functors) that could be formed in
the language.
What this means is that we consider for our category objects any object that
can be attained in a finite number from a finite number of functorial
applications from an object of $\mC$.

We consider for our types the quotient set
$\star = \mathrm{Obj}\left( \bar{\mC} \right)/\mF\left( \mL \right)$.
Since $\mF\left( \mL \right)$ does not induce an equivalence relation on
$\Obj\left( \bar{\mC} \right)$ but a preorder, we consider the chains obtained
by the closure of the relation $x\succeq y \Leftrightarrow \exists F, y = F(x)$
(which is seen as a subtyping relation as proposed in
\cite{melliesFunctorsAreType2015}).
We also define $\star_{0}$ to be the set obtained when considering types which
have not yet been \emph{affected}, that is $\Obj(\mC)$.
In contexts of polymorphism, we identify $\star_{0}$ to the adequate subset of
$\star$.
In this paradigm, constant objects (or results of fully done computations) are
functions with type $\bot \to \tau$ which we will denote directly by
$\tau \in \star_{0}$.

\subsubsection{Functors, Applicatives and Monads}
\label{subsubsec:functors}
Our point of view leads us to consider \emph{language functors}\footnote{The
	elements of our language, not the categorical construct.} as polymorphic
functions: for a (possibly restrained, though it seems to always be $\star$)
set of base types $S$, a functor is a function
\begin{equation*}
	x: \tau\in S\subseteq \star \mapsto F x: F\tau
\end{equation*}
This means that if a functor can be applied to a type, it can also be applied
to all \emph{affected} versions of that type, i.e.
$\mF\left( L \right)(\tau\in \star)$.
This gives us two typing judgements for the functor $F$:
\begin{equation*}
	\frac{\Gamma\vdash x: \tau \in \star_{0}}{\Gamma\vdash F x: F\tau \notin
		\star_{0}} \hspace{2cm} \frac{\Gamma\vdash x:
		\tau}{\Gamma\vdash Fx : F\tau\preceq \tau}
\end{equation*}
We use the same notation for the \emph{language functor} and the
\emph{type functor} in the examples, but it is important to note those are two
different objects, although connected.
More precisely, the \emph{language functor} is to be seen as a function whose
computation yields an effect, while the \emph{type functor} is the endofunctor
of $\bar{\mC}$ (so a functor from $\mC$) that represents the effect in our
typing category.
Examples are provided in Figure \ref{fig:functors}.

\smallskip

In that sense, applicatives and monads only provide with more flexibility on
the ways to combine functions:
they provide intermediate judgements to help with the combination of trees.
For example, the multiplication of the monad provides a new
\emph{type conversion} judgement:
\begin{equation*}
	\frac{\Gamma\vdash x: MM\tau}{\Gamma\vdash x: M\tau \succeq MM\tau}
\end{equation*}
This is actually a special case of the natural transformation rule that we
define below, which means that, in a way, types $MM\star$ and $M\star$ are
equivalent, as there is a canonical way to go from one type to another.
Remember however that $M\star$ is still a proper subtype of $MM\star$ and that
the objects are not actually equal: they are simply equivalent.

\subsubsection{Natural Transformations}
\label{subsubsec:transnat}
We could also add judgements for adjunctions, but the most interesting thing is
to add judgements for natural transformations, as adjunctions are particular
examples of natural transformations which arise from \emph{natural} settings.
While in general we do not want to find natural transformations, we want to be
able to express these in three situations:
\begin{enumerate}
	\item Adjunctions.
	\item To deal with the resolution of effects as explained in Section
	      \ref{sec:nondet}
	\item To create \emph{higher-order} constructs which transform words from our
	      language into other words, while keeping the functorial aspect.
	      This idea is developed in Section \ref{par:higherorder}.
\end{enumerate}
To see why we want this rule, which is a larger version of the monad
multiplication and the monad/applicative unit, it suffices to see that the
diagram defining the properties of a natural transformation provides a way
to construct the \emph{correct function} on the \emph{correct functor} side of
types.

\smallskip

In the Haskell programming language, any polymorphic function is
a natural transformation from the first type constructor to the second type
constructor, as proved by \cite{wadlerTheoremsFree1989}.
This will guarantee for us that given a \emph{Haskell} construction for a
polymorphic function, we will get the associated natural transformation.

\paragraph{Handlers}
\label{par:handlers}
As introduced:ways by \cite{marsikAlgebraicEffectsHandlers}, the use of handlers
as annotations to the syntactic tree of the sentence is an appropriate
formalism.
This could also give us a way to construct handlers for our effects as per
\cite{bauerEffectSystemAlgebraic2014}, or
\cite{plotkinHandlingAlgebraicEffects2013}.
As considered by \cite{wuEffectHandlersScope2014} and
\cite{vandenbergFrameworkHigherorderEffects2024}, handlers are to be seen
as natural transformations describing the free monad on an algebraic effect.
Considering handlers as so, allows us to directly handle our computations
inside our typing system, by ``transporting'' our functors one order higher up
without loss of information or generality since all our functors undergo the
same transformation.
Using the framework proposed in \cite{vandenbergFrameworkHigherorderEffects2024}
we simply need to create handlers for our effects/functors and we will then
have in our language the result needed.
The only thing we will require from an algebraic handler $h$ is that for any
applicative functor of unit $\eta$, $h\circ \eta = \id$.

\smallskip

Note that the choice of the handler being part of the lexicon or the parser
over the other is a philosophical question more than a semantical one, as both
options will result in semantically equivalent models, the only difference will
be in the way we consider the resolution of effects.
This choice does not arise in the case of the adjunction-induced
handlers.
Indeed here, the choice is caused by the non-uniqueness of the choices for
the handlers as two different speakers may have different ways to resolve the
non-determinism effect that arises from the phrase \textsl{A chair}.
This is the difference with the adjunctions: adjunctions are intrinsic
properties of the coexistence of the effects, while the handlers
are user-defined.

\paragraph{Higher-Order Constructs}
\label{par:higherorder}
Functors may also be used to add plurals, superlatives, tenses, aspects and
other similar constructs which act as function modifiers.
For each of these, we give a functor $\Pi$ corresponding to a new class of
types along with natural transformations for all other functors $F$ which
allows to propagate down the high-order effect.
This transformation will need to be from $\Pi \circ F$ to
$\Pi \circ F \circ \Pi$ or simply $\Pi \circ F \Rightarrow F \circ \Pi$
depending on the situation.
This allows us to add complexity not in the compositional aspects but
in the lexicon aspects, by simply saying that those constructs are predicate
modifiers passed down (with or without side effects) to the arguments of
predicates:
\begin{equation*}
	\begin{aligned}
		\mathbf{future\left( be \right)\left( arg_{1}, arg_{2} \right)}
		 & \xrightarrow{\eta} \mathbf{future\left( be \right)\left( arg_{2} \right)\left( future\left( arg_{1} \right) \right)}                           \\
		 & \xrightarrow{\eta} \mathbf{future \left( be \right) \left( future \left( arg_{2} \right) \right) \left( future \left( arg_{1} \right) \right)}
	\end{aligned}
\end{equation*}


\paragraph{Monad Transformers}
In \cite{bumfordEffectdrivenInterpretationFunctors2025}, the authors present
constructions which they call monad transformers or \emph{higher-order
	constructors} and which take a monad as input and return a monad as output.
One way to type those easily would be to simply create, for each such
construct, a monad (the result of the application to any other monad) and a
natural transformation which mimics the application and can be seen as the
constructor.

\subsection{Typing Judgements}\label{subsec:judgements}
To complete this section, Figure \ref{tab:judgements} gives a simple list of different typing composition judgements through which we also re-derzive the subtyping judgement to allow for its implementation.
\begin{figure}
	\input{typing-judgements}
	\caption{Typing and subtyping judgements for implementation of effects in the
		type system.}
	\label{tab:judgements}
\end{figure}
Note that here, the syntax is not taken into account: a function is always written left of its arguments, whether or not they are actually in that order in the sentence.

\smallskip

Using these typing rules for our semantic parsing steps, it is important to
see that our grammar will still be ambiguous.
The next sections will explain how to reduce this ambiguity in quick enough
time.

Moreover, the observant reader might have noticed that our typing system is not
decidable, because of the \texttt{nat/pure/return} rules which may allow for
unbounded derivations.
This is not actually an issue because of considerations on handling, as
semantically void units will get removed at that time.
This leads to derivations of sentences to be of bounded height, linear in the
length of the sentence.
