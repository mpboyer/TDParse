\section{Categorical Semantics of Effects: A Typing System}
In this section, we will formalize a type system underlying the theory proposed
in \cite{bumfordEffectdrivenInterpretationFunctors2025}.
To do so, we will designate by $\mL$ our language, as a set of words
(with their associated meaning/denotation) and syntactic rules underlying
the semantic combination.
The absence of syntactic rules is allowed, although it partly defeats the
purpose of this work.
This might be useful when proposing compositional models of learned
representations.

We will use $\mF\left( \mL \right)$ to denote the set of functors or
higher-order functions used in denotations of $\mL$.
Those are chosen when representing the language (see Figure \ref{fig:functors}
for examples), and should be additions to a simpler semantic theory.
Our goals here are to describe more formally, using a categorical vocabulary,
the environment in which the typing system for our language will exist, and how
we connect words and other linguistic objects to the categorical formulation.

\subsection{Typing Category}
\subsubsection{Types}
Let $\mC$ be a closed cartesian category representing the
domain of types for the domains and co-domains of uneffectful denotations.
$\mC$ is our \emph{main} typing system, consisting of types for words
that can be expressed without effects (see Figure \ref{fig:lexicon} for an
example).
The terminal object $\bot$ of $\mC$ represents the empty type or the lack
thereof.
We consider as our typing category $\bar{\mC}$ the categorical closure for
exponentials and products of $\mF\left( \mL \right)^{*}\left(\mC\right)$,
which consists of all the different type constructors (ergo, functors) that
could be formed in the language.
In that setting our types are those that can be attained from a finite number
of functorial applications from an object of $\mC$.

Since $\mF\left( \mL \right)$ only induces a preorder on
$\Obj\left( \bar{\mC} \right)$, we consider the relation on types
$x\succeq y \Leftrightarrow \exists F, y = F(x)$ (which should be seen
as a subtyping relation as proposed in \cite{melliesFunctorsAreType2015}).
We then consider for our types the quotient set
$\star = \Obj\left(\bar{\mC}\right) / ~$ where $~$ is the transitive closure of
the subtyping relationship induced by functorial application.
We also define $\star_{0}$ to be the subset of types containing only
uneffectful types, i.e. $\Obj(\mC)$.
In contexts of polymorphism, we identify $\star_{0}$ to the adequate subset of
$\star$.
In this paradigm, constant objects (or results of fully handled computations) are
functions with type $\bot \to \tau$ which we will denote directly by
$\tau \in \star_{0}$.
This will be useful when defining base combinators in Section \ref{sec:parsing}.

\subsubsection{Functors, Applicatives and Monads}
Our point of view has us consider \emph{language functors}\footnote{Words with
	denotations in $\mF(\mL)$ which represent denotationally effectful
	constructions, e.g. "a" or "the". They are to be considered with opposition to
	the \emph{type functors} which are the mathematical construct in $\mF(\mL)$.}
as polymorphic functions: for a
(possibly restrained) set of base types $S$, a functor is seen as a function:
\begin{equation*}
	x: \tau\in S\subseteq \star \mapsto F x: F\tau
\end{equation*}
This means that if a functor can be applied to a type, it can also be applied
to all \emph{affected} versions of that type, i.e.
$\mF\left( L \right)(\tau\in \star)$.
This gives us two typing judgements for the functor $F$:
\begin{equation*}
	\frac{\Gamma\vdash x: \tau \in \star_{0}}{\Gamma\vdash F x: F\tau \notin
		\star_{0}} \hspace{2cm} \frac{\Gamma\vdash x:
		\tau}{\Gamma\vdash Fx : F\tau\preceq \tau}
\end{equation*}
We use the same notation for the \emph{language functor} and the
\emph{type functor} in the examples, but it is important to note those are two
different objects, although connected.
More precisely, the \emph{language functor} is to be seen as a function whose
computation yields an effect, while the \emph{type functor} is the endofunctor
of $\bar{\mC}$ (so a functor from $\mC$) that represents the effect in our
typing category.
Examples of this difference are to be found in Figures \ref{fig:lexicon} and
\ref{fig:functors}.

\smallskip

In this regard, applicatives and monads only provide with more flexibility on
the ways to combine functions:
they provide intermediate judgements to help with the combination of trees.
For example, the multiplication of the monad provides a new \emph{type
	transformation} judgement allowing derivation of $M\tau$ from$MM\tau$.
This is a special case of the natural transformation rule that we
define in the next section.

\subsubsection{Natural Transformations}
We could add judgements directly for adjunctions and monads, but we generalize
by adding judgements for natural transformations, as adjunctions and monadic
rules are natural transformations which arise from \emph{natural} settings.
While in general we do not want to create natural transformations, we want to be
able to express these in three situations:
\begin{enumerate}
	\item Adjunctions, Monads and Co-Monads\footnote{Which are actually the same
		      thing.}.
	\item To deal with the resolution of effects as explained in Section
	      \ref{sec:nondet}
	\item To create \emph{higher-order} constructs which transform words from our
	      language into other words, while keeping the functorial aspect.
	      This idea is developed in Section \ref{par:higherorder}.
\end{enumerate}
To see why we want this rule, which is a larger version of the monad
multiplication and the monad/applicative unit, it suffices to see that the
diagram defining the properties of a natural transformation provides a way
to construct the \emph{correct function} on the \emph{correct functor} side of
types.
From a linguistic point of view, natural transformations allow us to reason
directly about type coercions and their coherence in the typing system,
whether that is transporting effects across functors as in Section
\ref{par:higherorder} or collapsing nested effects and more generally handling
them as presented in Section \ref{par:handlers} and \ref{sec:nondet}.

\smallskip

In the Haskell programming language, any polymorphic function is
a natural transformation from the first type constructor to the second type
constructor, as proved in \cite{wadlerTheoremsFree1989}.
This will guarantee for us that given a \emph{Haskell} construction for a
polymorphic function, we will get the associated natural transformation.

\paragraph{Handlers}
\label{par:handlers}
As introduced by \cite{marsikAlgebraicEffectsHandlers}, the notion of handlers
is to be considered as the way to solve effects that obfuscate the result of a
computation.
Following \cite{wuEffectHandlersScope2014}, we understand handlers as natural
transformations describing the resolution of an algebraic effect: they are
natural transformations from the effect to the identity functor, effectively
resolving them.
Considering handlers this way allows us to directly handle our computations
inside our typing system and in particular inside our parsing algorithm.
This process will mostly be described in Sections \ref{sec:nondet} and
\ref{sec:parsing}.

\smallskip

To define a handler $h$, we will only require that for any applicative functor
of unit $\eta$, $h\circ \eta = \id$.
This solves the issue of non-termination of the system.
Note that the choice of the handler being part of the lexicon or the parser
over the other is a philosophical question more than a semantical one, as both
options will result in semantically equivalent models, the only difference will
be in the way we consider the resolution of effects.
This choice does not arise in the case of the adjunction-induced
handlers.
Indeed here, the choice is caused by the non-uniqueness of the choices for
the handlers as two different speakers may have different ways to resolve the
non-determinism effect that arises from the phrase \textsl{A chair}.
This is the difference with the adjunctions: adjunctions are intrinsic
properties of the coexistence of the effects, while the handlers
are user-defined.

\paragraph{Higher-Order Constructs}
\label{par:higherorder}
Functors may also be used to add plurals, superlatives, tenses, aspects and
other similar constructs which act as function modifiers.
For each of these, we give a functor $\Pi$ corresponding to a new class of
types along with natural transformations for all other functors $F$ which
allows to propagate down the high-order effect.
This allows us to add complexity not in the compositional aspects but
in the model of the language, by simply saying that those constructs are
predicate modifiers passed down (with or without side effects) to the arguments
of predicates:
\begin{equation*}
	\begin{aligned}
		\mathbf{future\left( be \right)\left( arg_{1}, arg_{2} \right)}
		 & \xrightarrow{\eta} \mathbf{future\left( be \right)\left( arg_{2} \right)\left( future\left( arg_{1} \right) \right)}                           \\
		 & \xrightarrow{\eta} \mathbf{future \left( be \right) \left( future \left( arg_{2} \right) \right) \left( future \left( arg_{1} \right) \right)}
	\end{aligned}
\end{equation*}

Among other higher-order constructs that might be represented using effects are
scope islands, which could be modelled by a functor that cannot be
passed as argument to words that would otherwise need a closure to be applied
first.
See Figure \ref{fig:tree-rain} for an example, based on theory presented in
\cite{bumfordEffectdrivenInterpretationFunctors2025}, Section 5.4.

The term ''\emph{higher-order construct}'' comes from the idea that those
constructs are not generated by words but at the scale of the sentence, or even
the syntax in the case of \emph{scope islands}.
As such, we will say that this type of functors are \emph{external} to the
lexicon.

\subsection{Typing Judgements}\label{subsec:judgements}
To complete this section, Figure \ref{tab:judgements} gives a simple list of different typing composition judgements through which we also re-derive the subtyping judgement to allow for its implementation.
\begin{figure}
	\input{typing-judgements}
	\caption{Typing and subtyping judgements for implementation of effects in the
		type system.}
	\label{tab:judgements}
\end{figure}
Note that here, the syntax is not taken into account: a function is always written left of its arguments, whether or not they are actually in that order in the sentence.

\smallskip

Using these typing rules for our semantic parsing steps, it is important to
see that our grammar will still bear ambiguity.
The next sections will explain how to reduce this ambiguity in short enough
time.

Moreover, our current typing system is not decidable, because of the
\texttt{nat/pure/return} rules which may allow for unbounded derivations.
This is not actually an issue because of the considerations on handling, as
semantically void units will get removed at that time.
Indeed, from the property of handlers adding a unit and not modifying the
effect before it is handled does not change anything to the result and will be
removed.
This leads to derivations of sentences to be of bounded height, linear in the
length of the sentence.
