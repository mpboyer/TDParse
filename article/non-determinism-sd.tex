\section{Handling Ambiguity}
\label{sec:nondet}
The typing judgements proposed in Section \ref{subsec:judgements} lead to
ambiguity.
In this section we propose ways to get our derivations to a certain normal
form, by deriving an equivalence relation on our derivation and parsing trees,
based on string diagrams.

\subsection{String Diagram Modelisation of Sentences}
\label{subsec:sd}
String diagrams are the Poincar√© duals of the usual categorical diagrams when
considered in the $2$-category of categories and functors.
This means that we represent categories as regions of the plane, functors as
lines separating regions and natural transformations as the intersection points
between two lines.

We will always consider application as applying to the right of the line so
that composition is written in the same way as in equations.
This gives us a new graphical formalism to represent our effects using a few
equality rules between diagrams.
The commutative aspect of functional diagrams is now replaced by an equality of
string diagrams, which will be detailed in the following section.

We get a way to visually see the meaning get reduced from effectful composition
to propositional values, without the need to specify what the handler does.
This delimits our usage of string diagrams as ways to look at computations and
a tool to provide equality rules to reduce ambiguity.

\begin{wrapfigure}[17]{r}{.45\textwidth}
	\centering
	\input{sd-thecatsleeps}
	\caption{String diagram for the sentence \textsl{the cat sleeps}.}
	\label{fig:sd-thecatsleeps}
\end{wrapfigure}
Let us define the category $\mathds{1}$ with exactly one object and one arrow:
the identity on that object. It will be shown in grey in the string diagrams
below.
A functor of type $\mathds{1} \to \mC$ is equivalent to choosing an object in
$\mC$, and a natural transformation between two such functors $\tau_{1},
	\tau_{2}$ is exactly an arrow in $\mC$ of type $\tau_{1} \to \tau_{2}$.
Knowing that allows us to represent the type resulting from a sequence of
computations as a sequence of strings whose farthest right represents an object
in $\mC$, that is, a base type.

In the diagram of Figure \ref{fig:sd-thecatsleeps}, each string corresponds to
a functorial effect or type layer applied during parsing.
The base type string $\t$ is at the border of the gray area and is the one of
the uneffectful denotation in $\mC$ while the functorial string for $\f{M}$
introduces the effect for optionality and possible failure of the computation.
The question of providing rules to compose the string diagrams for parts of the
sentences will be discussed in the next section, as it is related to parsing.

\smallskip

In the end, we will have the need to go from a certain set of strings (the effects that applied) to a single one, through a sequence of handlers, monadic and comonadic rules and so on.
Notice that we never reference the zero-cells and that in particular their colors are purely an artistical touch.

\subsection{Achieving Normal Forms}
We will now provide a set of rewriting rules on string diagrams (written as
equations) which define the set of different possible reductions.

First, Theorem \ref{thm:isotopy} reminds the main result by \cite{joyalGeometryTensorCalculus1991} about string diagrams which shows that our artistic representation of diagrams is correct and does not modify the equation or the rule we are presenting.
\begin{theorem}[Theorem 1.2 \cite{joyalGeometryTensorCalculus1991}]
	\label{thm:isotopy}
	String diagrams equivalent under planar isotopy in the graphical language are equal.
\end{theorem}

A few equations on string diagrams also arise from the commutation of certain
class of diagrams and thus typing judgements.
We consider the \emph{snake} equations are a rewriting of the categorical
diagrams which are the defining properties of an adjunction and the
\emph{(co-)monadic} equations are the string diagrammatic translation of the
properties of unitality and associativity of monads.
These equations (and the reduction rules from Section \ref{subsec:rewrite})
explain all the different reductions that can be made to limit non-determinism
in our parsing and handling strategies.

\subsection{Computing Normal Forms}
Now that we have a set of rules telling us what we can and cannot do in our
model while preserving the equality of the diagrams, we provide a combinatorial
description of our diagrams to help compute the possible equalities between
multiple reductions of a sentence meaning.
In this section we formally describe the data structure we propose, as well as
proving our system of rewriting allows us to compute normal forms for our
diagrams.

\subsubsection{Representing String Diagrams}
We follow \cite{delpeuchNormalizationPlanarString2022} in their combinatorial
description of string diagrams.
We describe a diagram by an ordered set of its $2$-cells (the natural
transformations, including handlers of the diagram) along with the number of
input strings, for each $2$-cell we log the following information:
\begin{itemize}
	\item Its horizontal position: the number of strings that are right of it.
	\item Its type: an array of effects that are the inputs to the natural
	      transformation and an array of effects that are the outputs to the
	      natural transformation.
\end{itemize}
We will then write a diagram $D$ as a tuple of $3$ elements:
$\left( D.N, D.S, D.L \right)$ where $D.N$ is a positive integers representing the
height (or number of nodes) of $D$, $D.S$ is an array for the input strings of $D$ and
where $D.L$ is a function which takes a natural number smaller than $D.N - 1$ and
returns its type as a tuple of arrays
$nat = \left( \dnlg{nat}, \dnin{nat}, \dnout{nat} \right)$.
This gives a naive algorithm in polynomial time to check if a string diagram is
valid or not.

\smallskip

Because our representation contains strictly more information (without slowing
access by a non-constant factor) than the one it is based on, our
datastructure supports the linear and polynomial time algorithms proposed with
the structure by \cite{delpeuchNormalizationPlanarString2022}.
In particular our structure can be normalized in time
$\O\left( n \times \sup_{i} \abs{\dnin{\dlb{D}{i}}} + \abs{\dnout{\dlb{D}{i}}}
	\right)$, which depends on our lexicon but most of the times will be linear
time.

\subsubsection{Equational Reductions}
We are faced a problem when computing reductions using the equations for our diagrams
which is that by definition, an equation is symmetric.
To solve this issue, we only use equations from left to right to reduce as much as
possible our result instead.
Moreover, note that all our reductions are either incompatible or commutative, which
leads to a confluent reduction system, and the well definition of our normal forms.
\begin{theorem}[Confluence]
	\label{thm:confluence}
	Our reduction system is confluent and therefore defines normal forms:
	\begin{enumerate}
		\item Right reductions are confluent and therefore define \emph{right} normal forms for
		      diagrams under the equivalence relation induced by exchange.
		\item Equational reductions are confluent and therefore define \emph{equational}
		      normal forms for diagrams under the equivalence relation induced by exchange.
	\end{enumerate}
\end{theorem}

Before proving the theorem, let us first provide the reduction rules for the
different equations for our description of string diagrams.
\begin{description}
	\item[The Snake Equations]
	      First, let's see when we can apply the equation for $\id_{L}$ to a
	      diagram $D$ which is in \emph{right} normal form, meaning it's been
	      right reduced as much as possible.
	      Suppose we have an adjunction $L \dashv R$.
	      Then we can reduce $D$ along the equation at $i$ if, and only if:
	      \begin{itemize}
		      \item $\dnlg{\dlb{D}{i}} = \dnlg{\dlb{D}{i + 1}} - 1$
		      \item $\dlb{D}{i} = \eta_{L, R}$
		      \item $\dlb{D}{i + 1} = \epsilon_{L, R}$
	      \end{itemize}
	      This comes from the fact that we can't send either $\epsilon$
	      above $\eta$ using right reductions and
	      that there cannot be any natural transformations between the two.
	      Obviously the equation for $\id_{R}$ works the same.
	      Then, the reduction is easy: we simply delete both strings,
	      removing $i$ and $i + 1$ from $D$ and reindexing the other nodes.
	\item[The Monadic Equations] For the monadic equations, we only use
	      the unitality equation as a way to reduce the number of natural
	      transformations, since the goal here is to attain normal forms
	      and not find all possible reductions.
	      We ask that associativity is always used in the direct
	      sense $\mu\left( \mu\left( TT \right),T \right) \to \mu\left(
		      T\mu\left( TT \right) \right)$ so that the algorithm terminates.
	      We use the same convention for the comonadic equations.
	      The validity conditions are as easy to define for the monadic
	      equations as for the \emph{snake} equations when considering
	      diagrams in \emph{right} normal forms.
	      Then, for unitality we simply delete the nodes
	      and for associativity we switch the horizontal
	      positions for $i$ and $i + 1$.
\end{description}

\begin{proof}[Proof of the Confluence Theorem]
	The first point of this theorem is exactly Theorem 4.2
	in \cite{delpeuchNormalizationPlanarString2022}.
	To prove the second part, note that the reduction process terminates as
	we strictly decrease the number of $2$-cells with each reduction.
	Moreover, our claim that the reduction process is confluent is obvious
	from the associativity equation and the fact the other
	equations delete nodes.
	Since right reductions do not modify the equational reductions, and thus
	right reducing an equational normal form yields an equational normal form,
	combining the two systems is done without issue, completing our proof of
	Theorem \ref{thm:confluence}.
\end{proof}

\begin{theorem}[Normalization Complexity]
	\label{thm:norm}
	Reducing a diagram to its normal form is done in polynomial time in
	the number of natural transformations in it.
\end{theorem}
\begin{proof}
	Let's now give an upper bound on the number of reductions.
	Since each reductions either reduces the number of $2$-cells or applies the
	associativity of a monad, we know the number of reductions is linear in the
	number of natural transformations.
	Moreover, since checking if a reduction is possible at height $i$ is done in
	constant time, checking if a reduction is possible at a step is done in
	linear time, rendering the reduction algorithm quadratic in the number of
	natural transformations.
	Since \emph{right} normalizing in linear time before to ensure we get all
	equational reductions and after to complete the reduction is enough,
	we have a polynomial time algorithm.
\end{proof}

