\documentclass[math, english, info, noamsthm]{beamercours}
\makeatletter
\def\tikzimp@rt{1}
\makeatother

\usepackage[backend=biber, style=alphabetic]{biblatex}
\bibliography{slides.bib}
\setbeamertemplate{bibliography item}{}

\input{aux/preamble}

\title{Formalizing Typing Rules for Natural Languages using Effects}
\author{Matthieu Boyer}

\begin{document}
\maketitle

\section{Introduction}
\begin{frame}
	\frametitle{General Introduction}
	This work, based on \cite{bumfordEffectdrivenInterpretationFunctors2025} aims
	to provide a categorical formalization of a type and effects system for
	semantic interpretation of the natural language.

	\medskip

	We will develop a graphical formalism for semantic type-driven parsing and prove it is
	equivalent to a miinmalistic coloured merge interpretation of syntax.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Types in Semantics of Natural Languages}
	\setcellgapes{3pt}
	\makegapedcells
	\begin{NiceTabular}{>{\bf}LLL}
		Expression & \rm Type & \lambda\text{-Term} \\
		\word{planet}{\e\to\t}{\lambda x. \w{planet} x}{common nouns}
		\word{carnivorous}{\left( \e \to \t \right)}{\lambda x. \w{carnivorous}x}{predicative adjectives}
		\word{skillful}{\left( \e \to \t \right) \to \left( \e \to \t \right)}{\lambda p. \lambda x. px \land \w{skillful} x}{predicate modifier adjectives}
		\word{Jupiter}{\e}{{\bf j}\in \Var}{proper nouns}
		\word{sleep}{\e \to \t}{\lambda x. \w{sleep} x}{intransitive verbs}
		\CodeAfter
		\begin{tikzpicture}
			\draw[double] (1|-2) -- (4|-2);
			\foreach \r in {4,6,...,10} {\draw (1|-\r) -- (4|-\r);}
		\end{tikzpicture}
	\end{NiceTabular}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Including Non-Determinisms and Anaphoras}
	What should be the type of expressions such as \textbf{a cat} or \textbf{Jupiter, a planet}?
	\pause

	\smallskip

	Since we should be able to use \textbf{a cat} and \textbf{the cat} interexchangebly - from a syntax point of view - they should have the same type.
	We use effects to do the difference between:
	\begin{equation*}
		\w{a\ cat} = \{c \mid \w{cat} c\}
	\end{equation*}
	\begin{equation*}
		\w{the\ cat} = x \text{ if } \mathbf{cat}^{-1}(\top) = \{x\} \text{ else } \#
	\end{equation*}
\end{frame}

\section{Category-Theoretical Type System}
\begin{frame}
	\frametitle{A Type and Effect System}
	Let $\mL$ be our language: a typed lexicon and syntactic rules.
	We only suppose that our words can be applied to one another in their
	denotation system.

	\pause

	Let $\mC$ be a cartesian closed category used for typing the lexicon.
	Let $\mathcal{F}(\mL)$ be a set of functors used for representing the words
	that add an effect to our language.

	\pause\smallskip

	We consider $\bar{\mC}$ the categorical closure of $\mC$ under the action
	of $\mathcal{F}(\mL)^{*}$.
	We close it for the cartesian product and exponential of $\mC$.

	\pause\smallskip

	We also introduce the notions of applicatives and monads, as they grant more
	flexibility with semantic combinations.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Typing Rules}
	\only<1-2>{We then have typing judgements for basic combinations:
		\begin{align*}
			\only<1>{
			\frac{\cont x: \tau \poulpe \cont F \in \mathcal{F}(\mL)}{\cont Fx: F\tau }\fracnotate{Cons}                                          \\[.25cm]
			\frac{\cont x: F\tau_{1} \poulpe \cont \phi: \tau_{1} \to \tau_{2}}{\cont \phi x: F\tau_{2} }\fracnotate{\texttt{fmap}}               \\[.25cm]
				\frac{\cont x: \tau_{1} \poulpe \cont \phi: \tau_{1} \to \tau_{2}}{\cont \phi x: \tau_{2}}\fracnotate{App}
			}
			\only<2>{
			\frac{\cont x: A\tau_{1} \poulpe \cont \phi: A\left( \tau_{1} \to \tau_{2} \right)}{\cont \phi x: A\tau_{2}}\fracnotate{\texttt{<*>}} \\[.25cm]
			}
		\end{align*}
	}
	\only<3>{Typing judgements for natural transformations:
		\begin{align*}
			\frac{\cont x: \tau}{\cont x: A\tau}\fracnotate{\texttt{pure/return}} \\[.25cm]
			\frac{\cont x: MM\tau}{\cont x: M\tau}\fracnotate{\texttt{>>=}}
		\end{align*}
		More generally:
		\begin{align*}
			\forall F \overset{\theta}{\Longrightarrow} G,\poulpe \frac{\cont x: F\tau \poulpe \cont G: S' \subseteq \star \poulpe \tau \in S'}{\cont x : G\tau}\fracnotate{\texttt{nat}}
		\end{align*}
		To ensure termination and decidability, we prevent the use of the unit rule
		out of the blue, more on that later.
	}
\end{frame}


\section{Effect Handling}
\begin{frame}
	\frametitle{Handlers}
	A handler for an effect $F$ is a natural transformation $F \Rightarrow \Id$.

	\smallskip

	Handlers are not generally language-defined and are speaker-dependent.
	Adjunctions and comonads provide handlers intrinsic to their effects.
	Handlers should also be exact inverses to monadic and applicative units:
	this justifies semantically why we can remove the usage of the unit rule out
	of certain situations.

	\smallskip

	A large question we have to solve before parsing is whether two denotations
	will always yield the same result, considering effect handling.
\end{frame}

\begin{frame}
	\frametitle{String Diagrams in Denotations - 1}
	We will represent our denotations as string diagrams to make computations
	easier and to better understand what happens to each effect when handling.

	\medskip

	This allows us to look at equality of string diagrams instead of complex
	commutative diagrams.

	\medskip

	What happens when combining diagrams and why they have such a shape will be
	detailed in the following section.
\end{frame}

\begin{frame}[fragile]
	\frametitle{String Diagrams in Denotations - 2}
	\begin{center}
		\begin{tikzpicture}
			\path coordinate[dot, label=right:$\w{the}$] (the) + (0, 1) coordinate[dot, label=left:$\w{sleeps}$] (sleeps) + (0, 2) coordinate[label=above:$\t$] (bool)
			++(-2, 1) coordinate (ctlthe) + (0, 1) coordinate[label=above:$\f{M}$] (effthe)
			++(2, -2) coordinate[dot, label=left:$\w{cat}$] (cat) + (0, -2) coordinate[label=below:$\bot$] (bot);
			\draw (cat) -- (the) -- (sleeps) -- (bool);
			\draw[name path=effect] (the) to[out=180, in=-90] (ctlthe) -- (effthe);
			\draw[dashed] (bot) -- (cat);
			\begin{pgfonlayer}{background}
				\fill[catone] (bot) rectangle ($(bool) + (1, 0)$);
				\fill[catmca] (bot) rectangle ($(effthe) + (-1, 0)$);
				\fill[catmc] (the) to [out=180, in=-90] (ctlthe) -- (effthe) -- (bool) -- (the);
			\end{pgfonlayer}
		\end{tikzpicture}
	\end{center}
\end{frame}

\begin{frame}
	\frametitle{String Diagram Isotopy}
	\begin{thm}[Theorem 3.1 \cite{selingerSurveyGraphicalLanguages2010}, Theorem 1.2 \cite{joyalGeometryTensorCalculus1991}]
		\label{thm:isotopy}
		A well-formed equation between morphism terms in the language of monoidal categories follows from the axioms of monoidal categories if and only if it holds, up to planar isotopy, in the graphical language.
	\end{thm}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Commutation in String Diagrams}
	\only<1>{First, the elevator equations are a consequence of \ref{thm:isotopy}:
		\begin{equation}
			\resizebox{.9\textwidth}{!}{\inputtikz{sd-elevator}}
			\label{eq:elevator}
			\tag{\href{https://Ã®.fr/ascenseurs}{\emoji{elevator}}}
		\end{equation}	}
	\only<2>{The Snake equations are a rewriting of the properties of an adjunction:
		\begin{equation}
			\resizebox{.5\textwidth}{!}{\inputtikz{sd-snake1}}
			\tag{\rotatebox[origin=c]{90}{\emoji{snake}}}
			\label{eq:snek1}
		\end{equation}		\vspace{-12pt}
	}
	\only<3>{The Monadic equations are a rewriting of the properties of a monad:
		\begin{equation}
			\resizebox{.5\textwidth}{!}{\inputtikz{sd-monad-mult}}
			\label{eq:muax}
			\tag{$\mu$}
		\end{equation}
	}
\end{frame}

\begin{frame}
	\frametitle{Reduction Scheme}
	\cite{delpeuchNormalizationPlanarString2022} proposed a combinatorial description to check
	in linear time for equality under Theorem \ref{thm:isotopy}.

	\pause\smallskip

	\begin{thm}[Confluence]\label{thm:confluence}
		Our reduction system is confluent and therefore defines normal forms:
		\begin{enumerate}
			\item Right reductions are confluent and therefore define \emph{right} normal forms for
			      diagrams under the equivalence relation induced by exchange.
			\item Equational reductions are confluent and therefore define \emph{equational}
			      normal forms for diagrams under the equivalence relation induced by exchange.
		\end{enumerate}
	\end{thm}
\end{frame}

\begin{frame}
	\frametitle{Polynomial Time Reductions}
	\begin{thm}[Normalization Complexity]
		\label{thm:normalize}
		Reducing a diagram to its normal form is done in quadratic time in
		the number of natural transformations in it.
	\end{thm}
	This is accomplished using a formalism based on \cite{delpeuchNormalizationPlanarString2022}.
\end{frame}

\section{Semantic Parsing}
\begin{frame}
	\frametitle{Combining Phrases}
	A natural way to do the parsing would be to compute the valid syntactic parsing trees and then to
	map our typing rules on top of those.

	\smallskip

	However, english is not a context-free language \cite{higginbothamEnglishNotContextFree1984}
	and is moreover inherently ambiguous as the sentence
	\textit{The man sees the girl with a telescope} proves it.
\end{frame}

\begin{frame}
	\frametitle{CFGs}
	We use a Context-Free Grammar to model our typing system and take its product with the syntax defining grammar.
	\begin{minipage}{\textwidth}
		\scriptsize
		\begin{multicols}{2}
			\def\arraystretch{1.2}
			\begin{mgrammar}
				\firstrule{\tau}{\tau \Rightarrow \tau}{}
				\grule{\scalar{\tau, \tau}}{}
				\grule{\bar{\tau}}{}
				\grule{\mathrm{F}\tau}{}
				\gskip
				\firstrule{\bar{\tau}}{\t \enspace|\enspace \e \enspace|\enspace \cdots}{}
				\gskip
				\firstrule{\mathrm{F}}{\mFunc\left(\mL\right)^{*}}{}
				\gskip
				\firstrule{\text{Tree}}{\tau, \tau}{}
			\end{mgrammar}

			\def\arraystretch{1}
			\begin{mgrammar}
				\firstrule{\text{SM}}{\combML \enspace|\enspace \combMR}{\fmap}
				\grule{\combUL \enspace|\enspace \combUR}{\tt pure}
				\grule{\combA}{\tt Struct}
				\grule{\combJ}{\tt join}
				\grule{\combC}{\tt counit}
				\grule{\combER \enspace|\enspace \combEL}{\tt eject}
				\grule{\combDN}{\tt closure}
				\gskip
				\firstrule{\text{M}}{\text{SM}, \text{M}}{}
				\grule{\text{BComb}}{}
				\gskip
				\firstrule{\text{BComb}}{\mathrm{>} \enspace|\enspace \mathrm{<} \enspace|\enspace \wedge \enspace|\enspace \vee}{}
			\end{mgrammar}
		\end{multicols}
	\end{minipage}
\end{frame}

\begin{frame}
	\frametitle{CFGs - 2}
	\begin{minipage}{\textwidth}
		\small
		\begin{multicols}{2}
			\def\arraystretch{1.2}
			\begin{mgrammar}
				\gskip
				\firstrule{>, \beta}{\left(\alpha\to \beta\right), \alpha}{}
				\firstrule{<, \beta}{\alpha, \left(\alpha \to \beta\right)}{}
				\firstrule{\wedge, \alpha \to \t}{\left(\alpha \to \t\right), \left(\alpha \to \t\right)}{}
				\firstrule{\vee, \alpha \to \t}{\left(\alpha \to \t\right), \left(\alpha \to \t\right)}{}
				\gskip
				\firstrule{\combJ_{\f{F}}\  \f{F}\tau}{\f{F}\f{F}\tau}{}
				\firstrule{\combDN_{\f{C}}\  \tau}{\f{C}_{\tau}\tau}{}
				\gskip
			\end{mgrammar}

			\def\arraystretch{1.3}
			\begin{mgrammar}
				\firstrule{\combML_{\f{F}} \left(\alpha, \beta\right)}{\f{F}\alpha, \beta}{}
				\firstrule{\combMR_{\f{F}} \left(\alpha, \beta\right)}{\alpha, \f{F}\beta}{}
				\firstrule{\combA_{\f{F}} \left(\alpha, \beta\right)}{\f{F}\alpha, \f{F}\beta}{}
				\firstrule{\combUR_{\f{F}} \left(\alpha \to \alpha', \beta\right)}{\f{F}\alpha\to \alpha', \beta}{}
				\firstrule{\combUL_{\f{F}} \left(\alpha, \beta\to \beta'\right)}{\alpha, \f{F}\beta \to \beta'}{}
				\firstrule{\combC_{\f{L}\f{R}} \left(\f{L} \alpha, \f{R}\beta\right)}{\left(\alpha, \beta\right)}{}
				\firstrule{\combER_{\f{R}} \left(\f{R}\left(\alpha \to \alpha'\right), \beta\right)}{\alpha\to \f{R}\alpha', \beta}{}
				\firstrule{\combEL_{\f{R}} \left(\alpha, \f{R}\left(\beta \to \beta'\right)\right)}{\alpha, \beta\to \f{R}\beta'}{}
			\end{mgrammar}
		\end{multicols}
	\end{minipage}
\end{frame}

\begin{frame}
	\frametitle{CFGs - 3}
	This grammar works in five major sections:
	\begin{enumerate}
		\item We reintroduce the grammar defining the type and effect system.
		\item We introduce a structure for the semantic parse trees and their labels,
		      the combination modes from
		      \cite{bumfordEffectdrivenInterpretationFunctors2025}.
		\item We introduce rules for basic type combinations.
		\item We introduce rules for higher-order unary type combinators.
		\item We introduce rules for higher-order binary type combinators.
	\end{enumerate}
\end{frame}

\begin{frame}
	\frametitle{Combinators}
	The combinators introduced in the previous table all have actual effects on the denotations:
	\begin{center}
		\scriptsize
		\input{aux/figures/combinator-denotations}
	\end{center}
	This is how we actually compute a denotation for a sentence knowing its components.
\end{frame}

\begin{frame}
	\frametitle{String Diagram Combination}
	Given our grammar, we could build parsing trees, but that would blur the actual usefulness of our grammar and our string diagrammatic representation of sentences.

	\medskip

	We thus consider diagrams whose $1$-cells are objects in $\bar{\mC}$, i.e. types and effects and whose natural transformations are the combinators of our grammar.
\end{frame}

\begin{frame}
	\frametitle{A Parsing Diagram}
	\vspace{-1.5cm}
	\begin{center}
		\raisebox{2cm}{\resizebox{\textwidth}{!}{\rotatebox{-90}{\inputtikz{parsing-diagram}}}}
	\end{center}
\end{frame}

\begin{frame}
	\frametitle{Another Parsing Diagram}
	\begin{center}
		\raisebox{2cm}{\resizebox{\textwidth}{!}{\rotatebox{-90}{\inputtikz{parsing-diagram2}}}}
	\end{center}
\end{frame}

\begin{frame}
	\frametitle{Coproduct approach to Syntax}
	In \cite{marcollimatildeetchomskynoametberwickrobertc.MathematicalStructureSyntactic},
	the theory that all syntactic operations can be expressed using the product and coproduct of a
	Hopf algebra is developed.

	\smallskip

	In an upcoming paper, Isabella Sentura and Matilde Marcolli prove using
	that approach that morphosyntactic trees and morphological trees added to
	syntactic trees yield the same results.

	In a similar fashion, as their is a trivial way to map our string diagrams
	to labelled trees as proposed in \cite{bumfordEffectdrivenInterpretationFunctors2025},
	and since labelled trees can be derived from coproducts and products, we
	show that our way of defining parsing is actually equivalent in its
	integrations to the minimalistic theory.

	\medskip

	A more direct proof is in the works.
\end{frame}

\appendix
\begin{frame}[allowframebreaks]
	\frametitle{Bibliography}
	\printbibliography{}
\end{frame}


\end{document}

