{-# LANGUAGE BlockArguments #-}
-- {-# LANGUAGE LambdaCase #-}

module Parser where

import Prelude hiding ( (<>), (^), Word, (*) )
import Control.Monad ( join, liftM2 )
import Data.Function ( fix )
import Data.Functor ( (<&>) )
import Data.List ( isPrefixOf, stripPrefix )
import Memo
import TypeSystem
import Lang

combineWith tag handler =
  curry $ fix $ memoizeTag tag . ((handler <$>) .) . typeCombinations

-- Use of a monad m is for easing memoization.
-- Returns a wrapped list of all possible combinations with their resulting type, given a pair of types.
-- This amounts to describing the rules of creation of the typing rules that propagate effects up.
-- The limitation on the number of effects should be done during parsing, according to some confluent rewriting system.
typeCombinations :: Monad m => ((Ty, Ty) -> m [(Mode, Denot, Ty)]) -> (Ty, Ty) -> m [(Mode, Denot, Ty)]
typeCombinations combine (l, r) =
  return (baseTypeCombinations l r)
  <+> case l of
    Eff f a | functor f ->
      combine (a, r) <&>
      map \(op, d, t) -> (ML f:op, denotOP (ML f) % d, Eff f t)
    _ -> return []

  <+> case r of
    Eff f b | functor f ->
      combine (l, b) <&>
      map \(op, d, t) -> (MR f:op, denotOP (MR f) % d, Eff f t)
    _ -> return []

  <+> case l of
    Eff f a | appl f ->
      combine (a, r) <&>
      map \(op, d, t) -> (UR f:op, denotOP (UR f) % d, Eff f t)
    _ -> return []

  <+> case r of
    Eff f b | appl f ->
      combine (l, b) <&>
      map \(op, d, t) -> (UL f:op, denotOP (UL f) % d, Eff f t)

  <+> case (l, r) of
    (Eff f a, Eff g b) | appl f ->
      combine (a, b) <&>
      liftM2 (\h (op, d, c) -> let m = A h
                                in (m:op, denotOP m % d, Eff h c)) (combineEffects f g)
    _ -> return []

  <+> case (l, r) of
    (Eff f a, Eff g b) | adjunction f g ->
      combine (a, b) <&>
      concatMap \(op, d, c) -> do (m, eff) <- [(Eps, id), (XL f Eps, Eff f)]
                                  return (m:op, denotOP m % d, eff c)
    _ -> return []

  where
    infixr 6 <+>
    (<+>) = liftM2 (++)


data SynTree
  = Leaf String Denot Ty
  | Branch SynTree SynTree
  | Island SynTree SynTree
  deriving ( Show, Eq )


coreParser ::
  Monad m
  => CFG
  -> ((Int, Int, Phrase) -> m [(Cat, SynTree)])
  ->  (Int, Int, Phrase) -> m [(Cat, SynTree)]
coreParser _ _ (_, _, [(s, sign)]) = return [(c, Leaf s d t) | (d, c, t) <- sign]
coreParser cfg parse phrase = concat <$> mapM help (bisect phrase)
  where
    bisect (lo, hi, u) = do 
      i <- [1 .. length u - 1]
      let (ls, rc) = splitAt i u
      let break = lo + i
      return ((lo, break - 1, ls), (break, hi, rs))
      

parser :: Lang -> Phrase -> [SynTree]
parser _ _ = []
